package com.example.bank.repository; // Adjust package as per your project structure

import com.example.bank.model.Address;
import com.example.bank.model.Bank;
import com.example.bank.model.Branch;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest // Loads the full Spring application context
@Transactional // Ensures each test method runs in a transaction and rolls back changes
class BranchRepositoryTest {

    @Autowired
    private BranchRepository branchRepository;

    @Autowired
    private BankRepository bankRepository; // Needed to save the Bank entity

    @Autowired
    private AddressRepository addressRepository; // Needed if you explicitly save addresses or manage them for other tests

    // Optional: Use @BeforeEach to ensure a clean state, though @Transactional often handles this for tests.
    // This is more useful if you have data that persists across transactions or want to guarantee isolation beyond rollback.
    @BeforeEach
    void setup() {
        // Clear data from previous tests if @Transactional isn't fully sufficient or for specific scenarios.
        // For @Transactional tests, usually not needed as rollback handles cleanup.
        // If you were testing outside @Transactional, this would be crucial.
        // branchRepository.deleteAllInBatch(); // Use InBatch for performance
        // bankRepository.deleteAllInBatch();
        // addressRepository.deleteAllInBatch();
    }

    @Test
    void findByBank_BankId_ShouldReturnAllBranchesForGivenBank() {
        // GIVEN: Prepare test data

        // 1. Create a Bank entity
        // DO NOT set bankId manually as it's @GeneratedValue(strategy = GenerationType.AUTO) for UUID
        Bank bank = new Bank();
        bank.setBankName("Global Bank Inc.");
        bank.setHeadOfficeAddress("100 Central Plaza, New York, USA");
        bank = bankRepository.save(bank); // Save the bank to persist it and get its generated UUID

        // Now, bank.getBankId() will return the UUID generated by JPA.

        // 2. Create Address entities
        // DO NOT set addressId manually as it's @GeneratedValue
        Address address1 = new Address(null, "10 Main St", "Mumbai", "Maharashtra", "400001", "India");
        Address address2 = new Address(null, "20 Park Ave", "Pune", "Maharashtra", "411001", "India");
        Address address3 = new Address(null, "30 High St", "Nagpur", "Maharashtra", "440001", "India");
        // No need to explicitly save addresses here if Branch.address has CascadeType.ALL
        // and you establish the bidirectional link correctly.
        // If you did `addressRepository.save(address1)` here, it would also work.

        // 3. Create Branch entities and link them to the Bank and Address
        Branch branch1 = new Branch();
        branch1.setBranchName("Mumbai Fort Branch");
        branch1.setIfscCode("GBIM0000001");
        branch1.setBank(bank); // Link to the persisted bank
        branch1.setAddress(address1); // Link to the address
        address1.setBranch(branch1); // Crucial: Set the inverse side for the @OneToOne relationship

        Branch branch2 = new Branch();
        branch2.setBranchName("Pune Shivaji Nagar Branch");
        branch2.setIfscCode("GBIP0000002");
        branch2.setBank(bank);
        branch2.setAddress(address2);
        address2.setBranch(branch2); // Crucial: Set the inverse side

        Branch branch3 = new Branch();
        branch3.setBranchName("Nagpur City Branch");
        branch3.setIfscCode("GBIN0000003");
        branch3.setBank(bank);
        branch3.setAddress(address3);
        address3.setBranch(branch3); // Crucial: Set the inverse side

        // 4. Save the Branch entities
        // Cascading from Branch to Address means addresses will also be persisted.
        branchRepository.save(branch1);
        branchRepository.save(branch2);
        branchRepository.save(branch3);

        // WHEN: Perform the action to be tested
        List<Branch> foundBranches = branchRepository.findByBank_BankId(bank.getBankId());

        // THEN: Assert the results
        assertNotNull(foundBranches, "The list of branches should not be null.");
        assertFalse(foundBranches.isEmpty(), "The list of branches should not be empty.");
        assertEquals(3, foundBranches.size(), "There should be exactly 3 branches for the given bank ID.");

        // Assert that all branches belong to the correct bank
        Bank finalBank = bank;
        assertTrue(foundBranches.stream().allMatch(b -> b.getBank().getBankId().equals(finalBank.getBankId())),
                "All found branches should belong to the correct bank.");

        // Assert that specific branches are present and their details are correct
        List<String> branchNames = foundBranches.stream()
                .map(Branch::getBranchName)
                .collect(Collectors.toList());

        assertTrue(branchNames.contains("Mumbai Fort Branch"), "Should find 'Mumbai Fort Branch'");
        assertTrue(branchNames.contains("Pune Shivaji Nagar Branch"), "Should find 'Pune Shivaji Nagar Branch'");
        assertTrue(branchNames.contains("Nagpur City Branch"), "Should find 'Nagpur City Branch'");

        // Further detailed assertion for one branch
        Branch mumbaiBranch = foundBranches.stream()
                .filter(b -> "Mumbai Fort Branch".equals(b.getBranchName()))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Mumbai Fort Branch not found"));

        assertEquals("GBIM0000001", mumbaiBranch.getIfscCode());
        assertNotNull(mumbaiBranch.getAddress(), "Mumbai Fort Branch should have an address.");
        assertEquals("Mumbai", mumbaiBranch.getAddress().getCity());
        assertEquals("400001", mumbaiBranch.getAddress().getZipCode());
        assertNotEquals("Null", mumbaiBranch.getAddress().getState(), "State should not be null or empty.");
        assertEquals(bank.getBankId(), mumbaiBranch.getBank().getBankId());
    }

    @Test
    void findByBank_BankId_ShouldReturnEmptyListForNonExistentBankId() {
        // GIVEN: A non-existent bank ID
        UUID nonExistentBankId = UUID.randomUUID(); // A random UUID that won't exist

        // WHEN: Perform the query
        List<Branch> foundBranches = branchRepository.findByBank_BankId(nonExistentBankId);

        // THEN: Assert that the list is empty
        assertNotNull(foundBranches, "The list should not be null even if empty.");
        assertTrue(foundBranches.isEmpty(), "The list of branches should be empty for a non-existent bank ID.");
        assertEquals(0, foundBranches.size(), "The size of the list should be 0.");
    }

    @Test
    void findByBank_BankId_ShouldReturnEmptyListForBankWithNoBranches() {
        // GIVEN: A bank with no associated branches
        Bank bankWithNoBranches = new Bank();
        bankWithNoBranches.setBankName("Lonely Bank");
        bankWithNoBranches.setHeadOfficeAddress("Nowhere, USA");
        bankWithNoBranches = bankRepository.save(bankWithNoBranches); // Save the bank

        // WHEN: Perform the query
        List<Branch> foundBranches = branchRepository.findByBank_BankId(bankWithNoBranches.getBankId());

        // THEN: Assert that the list is empty
        assertNotNull(foundBranches, "The list should not be null even if empty.");
        assertTrue(foundBranches.isEmpty(), "The list of branches should be empty for a bank with no branches.");
        assertEquals(0, foundBranches.size(), "The size of the list should be 0.");

    }
}